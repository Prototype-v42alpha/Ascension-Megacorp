#pragma kernel Init
#pragma kernel Update

struct Particle
{
    float3 position;
    float3 velocity;
    float life;
    float maxLife;
    float size;
    float3 color;
    float mass; // 1.0=核心, 0.5=剥离块, 0.0=散雾
};

RWStructuredBuffer<Particle> particleBuffer;

float deltaTime;
float time;
float3 emitterPos; 
float4 emitterPositions[8];
int emitterCount;
uint maxParticles;
float isEmitting;
float emitRate;
float2 windOffset;

float hash(uint n) {
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 789221U) + 1376312589U;
    return float(n & 0x7fffffffU) / float(0x7fffffff);
}

float3 random3(float seed) {
    return float3(
        hash(uint(seed * 1234.5678)),
        hash(uint(seed * 5678.9012)),
        hash(uint(seed * 9012.3456))
    );
}

[numthreads(64, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= maxParticles) return;
    particleBuffer[id.x].life = -1.0;
}

[numthreads(64, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= maxParticles) return;

    Particle p = particleBuffer[id.x];

    if (p.life > 0)
    {
        float distFromEmitter = distance(p.position, emitterPos);
        
        uint clumpId = id.x / 128;
        float clumpRnd = hash(clumpId);
        
        // === 剥离逻辑 ===
        if (p.mass > 0.8)
        {
            float peelThreshold = smoothstep(0.5, 3.5, distFromEmitter); 
            float peelChance = peelThreshold * 0.4; 
            float rndPeel = hash(id.x + uint(time * 30.0));
            
            if (rndPeel < peelChance * (0.5 + clumpRnd)) 
            {
                p.mass = 0.55; 
                float3 burstDir = random3(clumpId + time).xyz * 2.0 - 1.0;
                p.velocity += (burstDir * float3(1.2, 0.2, 1.2)) * 12.0;
            }
        }
        
        p.position += p.velocity * deltaTime;
        
        if (p.mass > 0.8)
        {
            float3 vibr = random3(id.x * 0.1 + time * 15) * 2.0 - 1.0;
            p.position += vibr * 0.03 * deltaTime;
        }
        else
        {
            float drag = lerp(12.0, 2.0, p.mass); 
            p.velocity *= max(0.0, 1.0 - drag * deltaTime);
            
            float vDecay = lerp(10.0, 1.5, p.mass);
            p.velocity.z *= max(0.0, 1.0 - vDecay * deltaTime);
            
            float windSens = 10.0 * (1.1 - p.mass);
            p.velocity.x += windOffset.x * windSens * deltaTime;
            p.velocity.z += windOffset.y * windSens * deltaTime;
            
            p.mass -= (0.5 + hash(id.x) * 0.2) * deltaTime;
            p.mass = max(0.0, p.mass);
            
            float3 offsetDir = random3(clumpId).xyz * 2.0 - 1.0;
            p.position += offsetDir * (5.0 * (1.0 - p.mass)) * deltaTime;
            
            p.position += (random3(id.x + time).xyz * 2.0 - 1.0) * 1.5 * deltaTime;
        }

        p.size = lerp(1.2, 0.15, p.mass); 
        
        float3 colCore = float3(0.85, 0.85, 0.80); 
        float3 colClump = float3(0.85, 0.85, 0.80); 
        float3 colMist = float3(0.95, 0.95, 0.93); 
        
        float scint = (hash(id.x * 23.0 + time) * 0.2 + 0.9);
        
        if(p.mass > 0.8) 
        {
            float coreFade = smoothstep(1.0, 0.4, p.life / p.maxLife); 
            p.color = lerp(colCore * 0.8, colClump, coreFade) * scint;
        }
        else if(p.mass > 0.4) 
        {
            float t = (p.mass - 0.4) / 0.4;
            p.color = lerp(colClump, colCore, t) * scint;
        }
        else 
        {
            float t = p.mass / 0.4;
            p.color = lerp(colMist, colClump, t) * scint;
        }
        
        p.life -= deltaTime;
    }
    else
    {
        if (isEmitting > 0.5 && emitterCount > 0)
        {
            float spawnProb = (emitRate * deltaTime) / maxParticles;
            float seed = id.x + time * 73.1;
            float rnd = hash(uint(seed * 1000.0));
            
            if (rnd < spawnProb) 
            {
                int emitterIdx = id.x % (uint)emitterCount;
                float3 targetEmitterPos = emitterPositions[emitterIdx].xyz;

                p.mass = 1.0; 
                p.life = 0.6 + hash(uint(seed * 123.4)) * 0.9; 
                p.maxLife = p.life;
                p.position = targetEmitterPos;
                p.position.x += (hash(uint(seed * 456.7)) * 2.0 - 1.0) * 0.15;
                p.position.z += (hash(uint(seed * 789.0)) * 2.0 - 1.0) * 0.05;
                
                float baseSpeed = 26.0 + hash(uint(seed * 321.0)) * 10.0; 
                float angle = (hash(uint(seed * 654.0)) * 2.0 - 1.0) * 0.05;
                p.velocity.x = sin(angle) * baseSpeed;
                p.velocity.z = cos(angle) * baseSpeed;
                p.velocity.y = 0;
            }
        }
    }
    particleBuffer[id.x] = p;
}
